---
layout: post
title: "The myth of the TTL in eBGP" 
slug: bgp-ttl
---

**Myth: **While having conversation with a friend, there was some confusion around the TTL value and eBGP peerings, the source of this confusion was coming from a book mentioning that the TTL of 1 was insufficient if peering between directly connected routers loopbacks. This is a common** **misconception I have frequently seen, and the idea here is to bust it.

**Topology**

```python
r1 ---f0/0--- r2
```

In the topology depicted above, we can observe **r1** and **r2** directly connected, and our BGP configuration is using the loopback address of each router respectively. For reachability between r1 and r2’s loopbacks we are using static routes. If we ping r2 from r1 loopback, we observe reachability is successful.


```python
r1#ping 2.2.2.2 source 1.1.1.1
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 2.2.2.2, timeout is 2 seconds:
Packet sent with a source address of 1.1.1.1
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 8/10/12 ms
```

Even though we have reachability, we can observe that the eBGP peering is not coming up between r1 and r2.

```python
r1#show ip bgp summary
BGP router identifier 1.1.1.1, local AS number 1
BGP table version is 1, main routing table version 1

Neighbor    	V       	AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd
2.2.2.2     	4        	2   	0   	0    	1	0	0 never	Idle
```

**Option 1: ebgp-multihop**

A widely known option is to set the **ebgp-multihop **command; this command would set the TTL field in the IP packet to 255 if not specified, and allow the session to be established. On both routers, we set the **ebgp-multihop **command.

```python
# r1
r1(config)#router bgp 1
r1(config-router)#neighbor 2.2.2.2 ebgp-multihop

# r1
r2(config)#router bgp 2
r2(config-router)#neighbor 1.1.1.1 ebgp-multihop

# logs
%BGP-5-ADJCHANGE: neighbor 2.2.2.2 Up
%BGP-5-ADJCHANGE: neighbor 1.1.1.1 Up
```

We can observe the logs that the peering is up on both routers, if we check the **show bgp ipv4 unicast summary **we can confirm this.


```python
r1#show bgp ipv4 unicast summary
BGP router identifier 1.1.1.1, local AS number 1
BGP table version is 1, main routing table version 1

Neighbor    	V       	AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd
2.2.2.2     	4        	2   	8   	8    	1	0	0 00:03:37    	0
```

The problem with this issue is that, before we even try to add the **ebgp-multihop** command the routers never try to send any TCP SYNs to each other. If we check the wire and start doing packet captures, we would not see any activity from BGP perspective being initiated from r1 or r2. Doing debugs, we will see that the router thinks there is no route to peer, even though there is actually no issues with reachability towards the neighbor’s IP address. Clearly the issue has to be something other than the TTL.

```python
r1#debug bgp all
BGP: 2.2.2.2 Active open failed - no route to peer, open active delayed 11264ms (35000ms max, 60% jitter)
```

**Option 2: disable-connected-check**

The issue with the lack of activity in the wire has to do with the internals of IOS. By default, IOS has the assumption that an eBGP peer IP must be a ‘C’ code route  or directly connected IP and not a remote destination coming from any other routing source. If a routing source other than ‘C’ is not available, the BGP peering would not be attempted - this is why you would not see any activity related to TCP port 179 in the wire.

To confirm this assumption, we can remove the **ebgp-multihop **command, clear the bgp session, and add the **disable-connected-check **command with this we would see that the peering would come up.

```python
# r1
r1(config-router)#neighbor 2.2.2.2 disable-connected-check

# r2
r2(config-router)#neighbor 1.1.1.1 disable-connected-check

# logs
%BGP-5-ADJCHANGE: neighbor 2.2.2.2 Up
%BGP-5-ADJCHANGE: neighbor 1.1.1.1 Up
```

If we check the TTL in the wire, we can see that the BGP packet is encapsulated in an IP packet with a TTL set to 1.

This check is enforced by the forwarding process (Cisco Express Forwarding - CEF) and is known as the **CEF Samecable** check. The hidden command <code>show ip cef &lt;detination> samecable<strong> </strong></code>provides the necessary information that allows us to confirm if the destination is directly connected or not.


```python
r1#show ip cef 2.2.2.2 samecable
 Prefix 2.2.2.2, connected interface: none
```

Note that the destination interface is set to **none**, this is due to the fact that the route **2.2.2.2/32 **is not **C - Directly connected**, but is a static route.

**Note:** Even if you change the static route towards 2.2.2.2/32 to have the interface FastEthernet0/0 as an exit, the interface field in the show ip cef samecable command would return ‘none’ as a result.

**Option 3:** **Distributing remote routes as directly connected**

By having the option of using Point-to-Point over Ethernet (PPPoE) we can leverage the peer neighbor route feature and send the loopbacks of the PEs via IPCP and allow r1 and r2 to see each other loopbacks as directly connected. Before continuing, let’s set the initial configuration on r1 and r2 as follows:

```python
#r1
hostname r1
!
interface Loopback0
 ip address 1.1.1.1 255.255.255.255
!
interface FastEthernet0/0
!
router bgp 1
 bgp log-neighbor-changes
 no bgp default ipv4-unicast
 neighbor 2.2.2.2 remote-as 2
 neighbor 2.2.2.2 update-source Loopback0
 !
 address-family ipv4
  neighbor 2.2.2.2 activate
 exit-address-family
!
end
```

```python
# r2
hostname r2
!
interface Loopback0
 ip address 2.2.2.2 255.255.255.255
!
interface FastEthernet0/0
!
router bgp 2
 bgp log-neighbor-changes
 no bgp default ipv4-unicast
 neighbor 1.1.1.1 remote-as 1
 neighbor 1.1.1.1 update-source Loopback0
 !
 address-family ipv4
  neighbor 1.1.1.1 activate
 exit-address-family
!
end
```

Let’s start with the PPPoE configuration, r1 in this case would be the client, and r2 would be designated as the PPPoE server.


```python
# r1 : PPPOE-Client

r1(config)#interface dialer1
r1(config-if)#ip unnumbered loopback0
r1(config-if)#dialer pool 1
r1(config-if)#encapsulation ppp

r1(config)#interface fastethernet0/0
r1(config-if)#pppoe-client dial-pool-number 1
```

```python
# r2 : PPPOE-Server

r2(config)#bba-group pppoe PPPOE_SERVER
(config-bba-group)#virtual-template 1
r2(config)#interface virtual-template 1
r2(config-if)#ip unnumbered lo0
r2(config-if)#encapsulation ppp
r2(config)#interface fastethernet0/0
r2(config-if)#pppoe enable group PPPOE_SERVER
```

If we check the PPPoE negotiations, we can observe something interesting coming up in the logs in the IPCP phase.

```python
Vi1 IPCP: Event[Receive ConfAck] State[ACKsent to Open]
Vi1 IPCP: State is Open
Di1 Added to neighbor route AVL tree: topoid 0, address 2.2.2.2
Di1 IPCP: Install route to 2.2.2.2 <<< ! Installing 2.2.2.2/32 route
```

If we check the routing table, we will observe r1 and r2 installing each other loopbacks via the PPP peer-neighbor-route feature installed as a ‘C’ - Connected route.

```python
# r1

r1#show ip route 2.2.2.2
Routing entry for 2.2.2.2/32
  Known via "connected", distance 0, metric 0 (connected, via interface)
  Routing Descriptor Blocks:
  * directly connected, via Dialer1
  	Route metric is 0, traffic share count is 1
```

```python
# r2

r2#show ip route 1.1.1.1
Routing entry for 1.1.1.1/32
  Known via "connected", distance 0, metric 0 (connected, via interface)
  Routing Descriptor Blocks:
  * directly connected, via Virtual-Access1.1
  	Route metric is 0, traffic share count is 1
```


This means that BGP the routes would pass the **CEF** **Samecable **check

```python
r1#show ip cef 2.2.2.2/32 samecable
 Prefix 2.2.2.2, connected interface: Dialer1
```

Which if our theory is correct, would mean that the eBGP peering would come up.

```python
r1#show bgp ipv4 unicast summary
BGP router identifier 1.1.1.1, local AS number 1
BGP table version is 1, main routing table version 1

Neighbor    	V       	AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd
2.2.2.2     	4        	2   	4   	4    	1	0	0 00:00:07    	0
```


I hope this brief article has helped to clarify the misconception about the TTL in eBGP peerings.
